# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, The Babel Team
# This file is distributed under the same license as the Babel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Babel 2.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-07 09:14+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../messages.rst:7
msgid "Working with Message Catalogs"
msgstr ""

#: ../../messages.rst:11
msgid "Introduction"
msgstr ""

#: ../../messages.rst:13
msgid ""
"The ``gettext`` translation system enables you to mark any strings used "
"in your application as subject to localization, by wrapping them in "
"functions such as ``gettext(str)`` and ``ngettext(singular, plural, "
"num)``. For brevity, the ``gettext`` function is often aliased to "
"``_(str)``, so you can write:"
msgstr ""

#: ../../messages.rst:22
msgid "instead of just:"
msgstr ""

#: ../../messages.rst:28
msgid "to make the string \"Hello\" localizable."
msgstr ""

#: ../../messages.rst:30
msgid ""
"Message catalogs are collections of translations for such localizable "
"messages used in an application. They are commonly stored in PO (Portable"
" Object) and MO (Machine Object) files, the formats of which are defined "
"by the GNU `gettext`_ tools and the GNU `translation project`_."
msgstr ""

#: ../../messages.rst:38
msgid ""
"The general procedure for building message catalogs looks something like "
"this:"
msgstr ""

#: ../../messages.rst:40
msgid ""
"use a tool (such as ``xgettext``) to extract localizable strings from the"
" code base and write them to a POT (PO Template) file."
msgstr ""

#: ../../messages.rst:42
msgid ""
"make a copy of the POT file for a specific locale (for example, "
"\"en_US\") and start translating the messages"
msgstr ""

#: ../../messages.rst:44
msgid ""
"use a tool such as ``msgfmt`` to compile the locale PO file into a binary"
" MO file"
msgstr ""

#: ../../messages.rst:46
msgid ""
"later, when code changes make it necessary to update the translations, "
"you regenerate the POT file and merge the changes into the various "
"locale-specific PO files, for example using ``msgmerge``"
msgstr ""

#: ../../messages.rst:50
msgid ""
"Python provides the :mod:`gettext` module as part of the standard "
"library, which enables applications to work with appropriately generated "
"MO files."
msgstr ""

#: ../../messages.rst:53
msgid ""
"As ``gettext`` provides a solid and well supported foundation for "
"translating application messages, Babel does not reinvent the wheel, but "
"rather reuses this infrastructure, and makes it easier to build message "
"catalogs for Python applications."
msgstr ""

#: ../../messages.rst:60
msgid "Message Extraction"
msgstr ""

#: ../../messages.rst:62
msgid ""
"Babel provides functionality similar to that of the ``xgettext`` program,"
" except that only extraction from Python source files is built-in, while "
"support for other file formats can be added using a simple extension "
"mechanism."
msgstr ""

#: ../../messages.rst:66
msgid ""
"Unlike ``xgettext``, which is usually invoked once for every file, the "
"routines for message extraction in Babel operate on directories. While "
"the per-file approach of ``xgettext`` works nicely with projects using a "
"``Makefile``, Python projects rarely use ``make``, and thus a different "
"mechanism is needed for extracting messages from the heterogeneous "
"collection of source files that many Python projects are composed of."
msgstr ""

#: ../../messages.rst:73
msgid ""
"When message extraction is based on directories instead of individual "
"files, there needs to be a way to configure which files should be treated"
" in which manner. For example, while many projects may contain ``.html`` "
"files, some of those files may be static HTML files that don't contain "
"localizable message, while others may be `Jinja2`_ templates, and still "
"others may contain `Genshi`_ markup templates. Some projects may even mix"
" HTML files for different templates languages (for whatever reason). "
"Therefore the way in which messages are extracted from source files can "
"not only depend on the file extension, but needs to be controllable in a "
"precise manner."
msgstr ""

#: ../../messages.rst:86
msgid ""
"Babel accepts a configuration file to specify this mapping of files to "
"extraction methods, which is described below."
msgstr ""

#: ../../messages.rst:94
msgid "Front-Ends"
msgstr ""

#: ../../messages.rst:96
msgid ""
"Babel provides two different front-ends to access its functionality for "
"working with message catalogs:"
msgstr ""

#: ../../messages.rst:99
msgid "A :ref:`cmdline`, and"
msgstr ""

#: ../../messages.rst:100
msgid ":ref:`setup-integration`"
msgstr ""

#: ../../messages.rst:102
msgid ""
"Which one you choose depends on the nature of your project. For most "
"modern Python projects, the distutils/setuptools integration is probably "
"more convenient."
msgstr ""

#: ../../messages.rst:111
msgid "Extraction Method Mapping and Configuration"
msgstr ""

#: ../../messages.rst:113
msgid ""
"The mapping of extraction methods to files in Babel is done via a "
"configuration file. This file maps extended glob patterns to the names of"
" the extraction methods, and can also set various options for each "
"pattern (which options are available depends on the specific extraction "
"method)."
msgstr ""

#: ../../messages.rst:118
msgid ""
"For example, the following configuration adds extraction of messages from"
" both Genshi markup templates and text templates:"
msgstr ""

#: ../../messages.rst:142
msgid ""
"The configuration file syntax is based on the format commonly found in "
"``.INI`` files on Windows systems, and as supported by the "
"``ConfigParser`` module in the Python standard library. Section names "
"(the strings enclosed in square brackets) specify both the name of the "
"extraction method, and the extended glob pattern to specify the files "
"that this extraction method should be used for, separated by a colon. The"
" options in the sections are passed to the extraction method. Which "
"options are available is specific to the extraction method used."
msgstr ""

#: ../../messages.rst:150
msgid ""
"The extended glob patterns used in this configuration are similar to the "
"glob patterns provided by most shells. A single asterisk (``*``) is a "
"wildcard for any number of characters (except for the pathname component "
"separator \"/\"), while a question mark (``?``) only matches a single "
"character. In addition, two subsequent asterisk characters (``**``) can "
"be used to make the wildcard match any directory level, so the pattern "
"``**.txt`` matches any file with the extension ``.txt`` in any directory."
msgstr ""

#: ../../messages.rst:158
msgid ""
"Lines that start with a ``#`` or ``;`` character are ignored and can be "
"used for comments. Empty lines are ignored, too."
msgstr ""

#: ../../messages.rst:161
msgid ""
"if you're performing message extraction using the command Babel provides "
"for integration into ``setup.py`` scripts, you can also provide this "
"configuration in a different way, namely as a keyword argument to the "
"``setup()`` function. See :ref:`setup-integration` for more information."
msgstr ""

#: ../../messages.rst:169
msgid "Default Extraction Methods"
msgstr ""

#: ../../messages.rst:171
msgid ""
"Babel comes with a few builtin extractors: ``python`` (which extracts "
"messages from Python source files), ``javascript``, and ``ignore`` (which"
" extracts nothing)."
msgstr ""

#: ../../messages.rst:175
msgid ""
"The ``python`` extractor is by default mapped to the glob pattern "
"``**.py``, meaning it'll be applied to all files with the ``.py`` "
"extension in any directory. If you specify your own mapping "
"configuration, this default mapping is discarded, so you need to "
"explicitly add it to your mapping (as shown in the example above.)"
msgstr ""

#: ../../messages.rst:185
msgid "Referencing Extraction Methods"
msgstr ""

#: ../../messages.rst:187
msgid ""
"To be able to use short extraction method names such as “genshi”, you "
"need to have `pkg_resources`_ installed, and the package implementing "
"that extraction method needs to have been installed with its meta data "
"(the `egg-info`_)."
msgstr ""

#: ../../messages.rst:191
msgid ""
"If this is not possible for some reason, you need to map the short names "
"to fully qualified function names in an extract section in the mapping "
"configuration. For example:"
msgstr ""

#: ../../messages.rst:205
msgid ""
"Note that the builtin extraction methods ``python`` and ``ignore`` are "
"available by default, even if `pkg_resources`_ is not installed. You "
"should never need to explicitly define them in the ``[extractors]`` "
"section."
msgstr ""

#: ../../messages.rst:215
msgid "Writing Extraction Methods"
msgstr ""

#: ../../messages.rst:217
msgid ""
"Adding new methods for extracting localizable methods is easy. First, "
"you'll need to implement a function that complies with the following "
"interface:"
msgstr ""

#: ../../messages.rst:237
msgid ""
"Any strings in the tuples produced by this function must be either "
"``unicode`` objects, or ``str`` objects using plain ASCII characters. "
"That means that if sources contain strings using other encodings, it is "
"the job of the extractor implementation to do the decoding to ``unicode``"
" objects."
msgstr ""

#: ../../messages.rst:243
msgid ""
"Next, you should register that function as an entry point. This requires "
"your ``setup.py`` script to use `setuptools`_, and your package to be "
"installed with the necessary metadata. If that's taken care of, add "
"something like the following to your ``setup.py`` script:"
msgstr ""

#: ../../messages.rst:257
msgid ""
"That is, add your extraction method to the entry point group "
"``babel.extractors``, where the name of the entry point is the name that "
"people will use to reference the extraction method, and the value being "
"the module and the name of the function (separated by a colon) "
"implementing the actual extraction."
msgstr ""

#: ../../messages.rst:263
msgid ""
"As shown in `Referencing Extraction Methods`_, declaring an entry point "
"is not  strictly required, as users can still reference the extraction  "
"function directly. But whenever possible, the entry point should be  "
"declared to make configuration more convenient."
msgstr ""

#: ../../messages.rst:273
msgid "Translator Comments"
msgstr ""

#: ../../messages.rst:275
msgid ""
"First of all what are comments tags. Comments tags are excerpts of text "
"to search for in comments, only comments, right before the python "
":mod:`gettext` calls, as shown on the following example:"
msgstr ""

#: ../../messages.rst:284
msgid ""
"The comments tag for the above example would be ``NOTE:``, and the "
"translator comment for that tag would be ``This is a comment about `Foo "
"Bar```."
msgstr ""

#: ../../messages.rst:287
msgid "The resulting output in the catalog template would be something like::"
msgstr ""

#: ../../messages.rst:294
msgid "Now, you might ask, why would I need that?"
msgstr ""

#: ../../messages.rst:296
msgid ""
"Consider this simple case; you have a menu item called “manual”. You know"
" what it means, but when the translator sees this they will wonder did "
"you mean:"
msgstr ""

#: ../../messages.rst:299
msgid "a document or help manual, or"
msgstr ""

#: ../../messages.rst:300
msgid "a manual process?"
msgstr ""

#: ../../messages.rst:302
msgid ""
"This is the simplest case where a translation comment such as “The "
"installation manual” helps to clarify the situation and makes a "
"translator more productive."
msgstr ""

#: ../../messages.rst:306
msgid ""
"Whether translator comments can be extracted depends on the extraction "
"method in use. The Python extractor provided by Babel does implement this"
" feature, but others may not."
msgstr ""

